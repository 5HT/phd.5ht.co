\addtocontents{toc}{\protect\newpage}

\chapter{Концептуальна модель формальної системи мов}
\epigraph{Присвячується автору ML, CCS, LCF, алгоритму HM, $\pi$-числення}{Артуру Джону Робіну Мілнеру}

Другий розділ описує розвиток концептуальної моделі системи доведення теорем як сукупності:
i) середовища виконання, яке складається з інтерпретатора та операційної системи;
ii) послідовності формальних мов програмування,
кожна наступна з яких, складніша за попередню,
має свою операційну семантику, та наслідує усі властивості
попередніх мов послідовності.

\section{Попередні відомості та теорії}
Для розповіді про систему доведення теорем, як систему мов програмування
будемо використовувати теорію категорії та теорію індуктивних
типів для специфікації синтаксисів мов програмування. Перелік необхідних формальних теорій:
лямбда числення, теорії індуктивних типів, вищі рівності для гомотопічної системи
тощо, містяться в розділі 3. Формальна теорія категорії міститься у розділі 4.
Слід зауважити, що ця формалізація проводиться на основі гомотопічної
мови програмування побудованої в даному розділі 2.

\begin{definition} (Концепт, Готлоб Фреге).
Концепт --- це предикат над об'єктом,
або іншими словами залежний $\Pi$-тип з теорії типів Мартіна-Льофа.
Об'єкт $x : o$ належить до концепту, тільки якщо сам концепт,
параметризований цим об'єктом, населений $p(o) : U$, де $p : concept(o)$.
\end{definition}

\begin{definition} (Система).
Визначимо систему як сукупність об'єктів $Ob : U$
та зв'язків між ними $Hom : Ob \rightarrow Ob \rightarrow U$.
\end{definition}

\begin{definition} (Концептуальна модель).
Таким чином концептуальна модель визначається як категорія, об'єкти якої
індексовані певною множиною, або залежні від параметра.
\end{definition}

\begin{definition} (Синтаксичне дерево).
Синтаксичне дерево --- це індуктивний тип або дерево Бома,
контруктори якого відповідають одному з 5 правил в теорії типів,
як правило використовуються три правила: правило формації, інтро-правила та елімінатор.
\end{definition}

\begin{definition} (Вище синтаксичне дерево).
Синтаксичне дерево в яке додано $\beta$ та $\eta$ правила називається
вищим синтаксичним деревом.
\end{definition}

\begin{definition} (Мова програмування).
Мова програмування або мовна категорія --- це категорія,
об’єкти якої --- це maybe-типи сум синтаксичних дерев мов програмування,
  а морфізми --- це стрілки (які містять правила виводу, типизації, нормалізації, екстакції тощо).
Приклади синтаксичних дерев: $O_\Pi$, $O_\Sigma$, $O_=$.
Приклади мовних категорій: $O_{PTS}$, $O_{MLTT}$, $O_{HTS}$.
\end{definition}

\begin{definition} (Модель).
Модель визначимо як систему формальних мов (об'єкти) разом з їх програмами,
та мовними перетвореннями (звязки) між ними для яких працює правило асоціативності
композиції та правила лівої і правої композиції з одиничними стрілками.
Іншими словами будемо розуміти тут категорну модель.
\end{definition}

\begin{definition} (Послідовність синтаксичних дерев). Кожна послідовність
синтаксичних дерев
\begin{equation}
O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I.
\end{equation}
генерує відповідну послідовність мов програмування
\begin{equation}
\begin{split}
O_{PTS}(O_\Pi) \rightarrow O_{CTX}(O_\Pi,O_\Sigma) \rightarrow O_{EQU}(..,O_\Sigma,O_=) \rightarrow \\
 \quad \rightarrow O_{ITS}(...,O_=,O_W) \rightarrow O_{HTS}(...,O_W,O_I).
\end{split}
\end{equation}
наступним чином. Кожна мова програмування залежить
від синтаксису який її визначає
та всіх попредніх синтаксисів мов програмування з послідовності.
Перша мова програмування містить тільки перший синтаксис.
Розкриті сигнатури мають вигляд:
$O_{PTS}: O_\Pi \rightarrow U$,
$O_{CTX}: O_\Pi \rightarrow O_\Sigma \rightarrow U$,
$O_{EQU}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow U$,
$O_{ITS}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow U$,
$O_{HTS}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I \rightarrow U$.
\end{definition}

Таким чином кожна наступна мова програмування містить усі попередні
мови програмування, визначені послідовністю синтаксичних дерев,

\begin{definition} (Створення мовної категорії).
Мови можна додавати, наприклад $O_{HTS} = O_{\Pi\Sigma=WI}$, для побудови якої необхідно
об'єднати у індуктивному типі мови усі індуктивні типи її підмов.
Таким чином функтор діє на декартовому добутку синтаксичних дерев мовних категорій
та має значення в категорій мовних категорій. Приклад найпотужнішої гомотопічної мови:
\begin{equation}
O_{HTS} = O_{\Pi\Sigma=WI} : O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I \rightarrow U.
\end{equation}
\end{definition}

Кожне синтаксичне дерево, як правило, містить конструктори
та елімінатори певного одного типу. Але починаючи з $O_{ITS}$
складність типів, які додаються до ядра значно зростає.
Таким чином мовні категорії конструються гранулярно з
точністю до включення певного типу в ядро верифікатора.

\begin{definition} (Типи синтаксичних дерев).
У розділі 1 були проаналізовані усі мови програмування та середовища виконання,
а також спеціалізовані мови моделювання. В результаті чого було встановлено
чітки індивідуальні мовні синтаксиси. Кожен синтаксис складається з
множини синтаксичних одиниць цієї мови (конструктори індуктивного типу),
які відповідають правилам теорії типів Мартіна-Льофа (формації, інтро-правило,
елімінатор, $\beta$-, та $\eta$-правила). Якщо додати $\beta$-, та $\eta$-правила
як рівності у визначення синтаксису, то для представлення потрібні вищі індуктивні типи.
Таким чином кожному синтаксичному дереву відповідає певний тип в теорії типів Мартіна-Льофа.
\begin{table}
%\centering
  \caption{Кластерний аналіз мовних синтаксисів}
 \begin{tabular}{lcccc}
    \hline
       Синтаксис & Мова програмування або її підмова \\
    \hline
       $O_\lambda$ & Нетипизоване $\lambda$-числення Чорча \\
       $O_\pi$     & Числення процесів, CCS, CSP або $\pi$-числення Мілнера\\
       $O_\mu$     & Тензорне числення та векторизація \\
    \hline
       $O_\Pi$     & Числення конструкцій (функціональна повнота) \\
       $O_\Sigma$  & Числення контекстів (контекстуальна повнота) \\
       $O_=$       & Теорія типів Мартіна-Льофа (логіка) \\
       $O_W$       & Числення індуктивних конструкцій (матіндукція) \\
       $O_I$       & Гомотопічна система типів (формальна математика) \\
      \hline
  \end{tabular}
\end{table}
\end{definition}

\begin{definition} (Спектральна категорія мов).
Так, виділяється наступна послідовність мов, та функторів між ними,
де кожна мова-кодомен є складнішою та біль потужною за мову-домен.
Система мов є категорією мовних категорій або категорією мов програмування.
\begin{equation}
O_\infty : O_{CPS} \rightarrow O_{PTS} \rightarrow O_{MLTT} \rightarrow O_{ITS} \rightarrow O_{HTS} \rightarrow ...
\end{equation}
\end{definition}

\begin{definition} (Коконтекстуальна категорія мов).
Якщо не виділяти певну послідовність мовного ускладнення та розглядати
усі суми усієї певної множини мовних синтаксисів, то ми отриміємо коконтекстуальну категорію,
де об'єкти --- це усі можливі мовні категорії побудовані за допомогою усіх перестановок суми мовних синтаксисів,
а морфізми це функтори перетворення однієї мовної категорії в іншу мовну категорію.
Приклади: $O_{I*} \rightarrow O_{\Pi=}$, $O_\Pi \rightarrow O_{\Pi\Sigma}$,
$O_\Pi \rightarrow O_{\Pi\Sigma}$, $O_{\Pi*} \rightarrow O_\Pi$.
\end{definition}

\section{Структурне представлення моделі}
Виходячи з визначення моделі, вони можуть мати різний
набір об'єктів в системі мов програмування.
Покажемо приклади ексземплярів які можно породити в рамках цієї моделі.

\subsection{Мінімальна система}
Приклад мінімальної системи, яка містить лише одну мову для доведення теорем
та одну мову для виконання програм.

\begin{equation}
PTS_{CPS} = 
\begin{cases}
Ob: \{ O_{CPS}, O_{PTS} \} \\
Hom: \{ 1,2: \mathbb{1} \rightarrow O_{PTS}, 3: O_{PTS} \rightarrow O_{CPS} \}
\end{cases}
\end{equation}

Стрілки 1 та 2 визначають
модель та базову бібліотеку, а стрілка 3 означає екстракт
доведення (якщо таке є) в інтерпретатор. Можна використати графічну
мову мереж Петрі для зображення екземпляра моделі системи мов.

\begin{figure}
  \centerline{\includegraphics[scale=0.6]{minimal.eps}}
  \caption{Мінімальна система з чистої мови та інтерпретатора}
\end{figure}

\subsection{Максимальна система}
Інший приклад системи --- це максимальна система, яка містить усі формальні
мови програмування та формальне середовище виконання (порядок синтаксичних дерев
як параметрів при конструюванні мовної категорії може змінюватися, тут
генеалогія HTS не ведеться від MLTT, яке є розгалуженням).
\begin{equation}
Total = 
\begin{cases}
Ob: \{ O_{CPS}, O_{PTS}, O_{MLTT}, O_{ITS}, O_{HTS} \} \\
Hom: \begin{cases}
1,2: \mathbb{1} \rightarrow O_{HTS}, 3: O_{MLTT} \rightarrow O_{ITS} \\
4: O_{HTS} \rightarrow O_{ITS}, 5: O_{ITS} \rightarrow O_{PTS}, 6: O_{PTS} \rightarrow O_{CPS}
\end{cases}
\end{cases}
\end{equation}
За допомогою мереж Петрі це можна відобразити наступним чином:
\begin{figure}[ht]
  \centerline{\includegraphics[scale=0.6]{higher.eps}}
  \caption{Кубічна та чиста системи типів та середовище виконання}
\end{figure}


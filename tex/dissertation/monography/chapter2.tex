\addtocontents{toc}{\protect\newpage}

\chapter{Концептуальна модель формальної системи мов}
\epigraph{Присвячується автору унівалентних основ математики}{Володимиру Воєводському}

Другий розділ описує розвиток концептуальної моделі системи доведення теорем як сукупності:
1) категорій, які розкривають семантику конкретної теорії типів (мови програмування) як синтаксису, або є її метатеорією.
2) теорії для маніпуляції мовними синтаксисами та программами (мовні категорії).
Ця концептуальна модель є сокупністю категорій, що пропонує фреймворк або стандарт
на розробку та формалізацію формальних мов. Усі мови програмування та їх моделі представлені
за допомогою цього фреймворка, пропонують сучасну математичну метатеоретичну основу для
мов програмування (імплементації конкретних теорій типів).

В наступних розділах 3 та 5 присвячених теоріям типів для програмування та доведення теорем
буде йтися виключно про теоретико-типові моделі, тобто мови програмування побудовані
на конкретних синтаксисах які представлені індуктивними типами. Цей розділ буде включати
набір моделей, які використовуються для дослідження категорної семантики типових систем.
Теоретичні засади фібраційного категорного фундаменту були закладені Александром
Гротендіком в 1971 році.

\section*{Вступне слово}
Категорні засади залежної теорії були побудовані Робертом Сілі. \cite{Seely84}.
Семантика залежної теорії поліморного лямбла числення вищих порядків
вивчається локальними декартово замкненими категоріями (ДЗК) --- категоріями з кінечними лімітами,
де слайс-категорії по будь-якому об'єкту є декартово-замкненими.

Перші спрови побудови повної формальної категорної семантики теорії типів були дані
Томасом Страйхером в 1991 році \cite{Streicher91}. Пітер Диб'єр запропонував категорну модель з
сімействами (Categories with Families, CwF) в 1995 році \cite{Dybjer95}, а також Мартін Хофман показав, що ці
категорії ізоморфні категоріям з атрибутами (Categoties with Attributes, CwA) в 1997 році \cite{Hofmann97}.
Стів Еводі в 2016 запропонував трохи модифіковану категорну досніпову модель теорії типів,
яку назвав природньою моделлю теорії типів \cite{Awodey17NaturalModels}.

Головною проблемою представлення категорної семантики теорії типів, крім доведення корекності та повноти,
є теорема про ініціальність, яка говорить, що ініціальними об'єктами в категорії моделей системи типів повинна бути модель термів.
Таким чином, теорії типів пакуються в категорних моделі, які містять усі
необхідні теореми пов'язані з когерентністью (яка була вирішена в категоріях розширень\cite{Lumsdaine15}) усіх композицій, рівняннями та властивостями
нормалізації та обчислень, канонічного представлення, тощо. Повна формальна ініціальна модель MLTT була
представлена на Agda лише в 2020 році за допомогою алгебраїчної теорії
категорій \footnote{\url{https://github.com/guillaumebrunerie/initiality} -- доведення кон'юнктури ініціальності MLTT}.

Генеалогічна лінія передачі 2-категорного моделювання бере початок з шостої глави SGA-1 лекцій Александра Гротендіка 1971 \cite{SGA1}.
В 1984 році Сілі \cite{Seely84} опублікував роботу по локальним ДЗК, однак в такій моделі кожна
стрілка є типом, що недостатньо деталізує модель. Інший підхід запропонований Джоном Картмелом \cite{Cartmell86} полягав
в створенні контекстуальних категорій, що дозволяв більш простіше і безпосередніше виражати природу залежних термів.
Ці дві моделі були уніфіковані Томасом Ерхардом в 1988 році \cite{Ehrhard88} більш абстрактною моделлю,
яка була глибшою і тим ближчою до оригіналу (SGA-1), в цій моделі були представлені категорії розширень.
Категорії розширень Гротендіка також можна знайти в роботах Барта Якобса\cite{Jacobs93}\cite{Jacobs99}.

Модельні категорії Деніела Квіллена \cite{Quillen67} пропонують ще вищий спосіб представлення,
де розкривається глибинна структура просторів за допомогою слабких систем факторизації.
Для сучасних математичних мов програмування (кубічна теорія типів) побудовані модельні категорії Квіллена,
однак кон'юнктура ініціальності залишається відкритою проблемою (станом на 2020 рік).

Подальші дослідження Террі Кокана категорних моделей теорії типів виходять на давню мрію
Гротендіка про стекову модель, де замість досніпа зі значенням в категорії множин,
береться функтор зі значеннями в категорії вищих групоїдів \cite{Coquand17Stack}.

\subsection*{Кон'юнктура ініціальності}
Кон'юнктура ініціальної в теорії типів стверджує, що модель термів (всі терми і всі типи)
певної системи типів повинна бути ініціальним об'єктом в категорії моделей цієї
системи типів. Ініціальність валідує формальний перехід від теорії категорії до
системи типів, таким чином, що синтаксичні пруфтерми системи типів в точності
відповідають теоремам в категорії, які інтерпретують ці системи типів.

Вперше ініціальність для чистих систем (Pure Type Systems), які складаються з одного П-типу,
була дана Томасом Страйхером. З тих пір Ініціальний для більш складних
типових систем, як то Martin-Löf Type Theory (MLTT), вважалася досягнута, вважаючи
механічне продовження техніки категорного формалізації для інших типів ($\Pi$, $\Sigma$, $=$, $+$, $\bot$, $\top$, $N$, $U_i$, $El$).
Хоча багато дослідників, починаючи з Володимира Воєводського і його серії статей
присвячених важливості механістичної формалізації кон'юнктури ініціальної в 2015-2017 рр,
займалися дослідженнями ініціальності, але лише в 2020 році Гійом Брунері та Пітер Люмсдейн
спільно з Менно де Боєр і Андерсом Мöртбергом представили формальну модель ініціальної
MLTT на Agda.

\newpage
\section{Концепти та Категорії}
Концепти Фреге були першою спробою фібраційної формалізації основи для математичних тверджень,
яка складається з розшарування (за допомогою якого моделюється квантор узагальнення) та
тотального простору (за допомогою якого моделюється квантор існування).

\begin{definition} (Концепт, Готлоб Фреге).
Концепт --- це предикат над об'єктом, або іншими словами залежний $\Pi$-тип з теорії типів Мартіна-Льофа.
Об'єкт $x : o$ належить до концепту, тільки якщо сам концепт,
параметризований цим об'єктом, населений $p(o) : U$, де $p : concept(o)$.
\end{definition}

\begin{definition} (Система).
Визначимо систему як сукупність об'єктів $Ob : U$
та зв'язків між ними $Hom : Ob \rightarrow Ob \rightarrow U$.
\end{definition}

\begin{definition} (Концептуальна модель).
Таким чином концептуальна модель визначається як категорія, об'єкти якої
індексовані певною множиною, або залежні від параметра.
\end{definition}

\section{Категорні моделі мов}
Для того аби показати сучасну досніпову категорну модель теорії типів,
дамо которкий опис теорії які лягли в основу категорного моделювання теорії типів.

\subsection{Локальні декартово-замкнені категорії Сілі}
Локальні декартово-замкнені категорії (ДЗК) та їх зв'язок з теорією типів були представлені Сілі\cite{Seely84}.
Внутрішньою мовою локальниз ДЗК є мова програмування з залежними типами $\Pi$ та $\Sigma$, що становить основу сучасних фібраційних пруверів.
Доведення, що декартово замкнена категорія містить STLC надано в розділі 7 математичних компонент
в рамках топосо-теоретичної моделі конструктивної теорії множин.

\newpage
\subsection{Обширні категорії Гротендіка}

\begin{definition} (Декартовий функтор). Нехай $p : E \rightarrow B$ --- функтор, функтор $f : D \rightarrow E$
називається дакартовим, якщо: 1) $pf = u$; 2) для кожного $f' : D' \rightarrow E$ такого що $pf' = u$ існує
унікальний функтор $\phi : D' \rightarrow D$, такий що $p\phi = id_A$ та $f' = f \circ \phi$.
\end{definition}

\begin{definition} (Категорія стрілок).

\begin{definition} (Розшарована категорія). Функтор $p : E \rightarrow B$ називається розшарованою категорією, якщо:
1) для кожного $e : E$ та $u : A \rightarrow pE \in B$ існую декартовий функтор $f : D \rightarrow E$ над $u$ в $E$;
2) композиція двох декартових функторів є декартовим функтором.
\end{definition}

\begin{definition} (Обширна категорія). Функтор $p : E \rightarrow B^\rightarrow$ називається обширною категорією, якщо:
1) $cod \circ p : E \rightarrow B$ є декартовим функтором;
2) для кожного декартового функтора $f \in E$ значення функтора $p$ в точці $f$ є пулбеком в $B$.
\end{definition}

\newpage
\subsection{Категорії з сімействами Диб'єра}
Узагальнена алгебраїчна теорія Пітера Диб'єра \cite{Dybjer95}\cite{Dybjer08}\cite{Abel08}.

\begin{definition} (Категорія з сімействами). Категорія $C$, об'єкти якої $Ob_C$ це простори залежних функцій $\Pi(A,B)$,
а морфізми $Hom_C(\Pi(A,B),\Pi(A',B')$ пари функцій $[f:A \rightarrow A',g(x:A) : B(x) \rightarrow B'(f(x))$.
\end{definition}

\begin{definition} (Категорія контекстів). Категорія, об'єкти якої є усі можливі контексти,
а морфізми усі можливі підстановки.
\end{definition}

\begin{lstlisting}
def CwF : U := Σ (C: precategory) (T: catfunctor C Fam)
    (context: isContext C) (terminal: isTerminal C), isComprehension C T
\end{lstlisting}


\newpage
\subsection{Природні моделі Еводі}
Сучасна категорна досніпова модель теорії типів, яка була представлена Стівом Еводі та активно
розроблюєтся в університеті Карнегі-Мелона.

\begin{definition} (Досніп). Досніп на категорії $C$ визначається як
функтор $F: C^{op} \rightarrow \mathbf{Set}$ з оберненої до $C$ категорії
в категорію множин $\mathbf{Set}$.
\end{definition}

\begin{definition} (Природна модель). Природна модель складається з:
1) категорії $C$;
2) виділеного термінального об'єкту $t \in C$;
3) досніпів $Ty, Tm : C^{op} \rightarrow \mathbf{Set}$;
4) природнього перетворення $p : Tm \rightarrow Ty$.
\end{definition}

\begin{lstlisting}
def naturalModel : U := Σ (C  : precategory) (_  : isCategory C)
    (t  : terminal C) (Tm : carrier C) (Ty : carrier C)
    (p  : hom C VT V), Π (f : homTo C V), hasPullback C (Tm, f, Ty, p)
\end{lstlisting}

Володимир Воєводський запропонував свою категорну модель, яку назвав $C-$системами.
В бібліотеці математичних компнент розділу 7 представлене доведення ізоморфізму $C-$систем
Воєводсього природним моделям Еводі.

\begin{definition} (Репрезентативні природні перетворення).
Для двох досніпів $P,Q : C^{op} \rightarrow \textbf{Set}$ та природнього
перетворення $\alpha : Q \rightarrow P$, $\alpha$ називається репрезентативним
якщо для всіх $Ob(C)$ та $x : Ob(C)$ існує $p_x : D \rightarrow C$ та $y : Q(D)$,
такий що цей квадрат комутує:
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=2em]
  {
     y(D) & Q \\
     y(C) & P \\};
  \path[-stealth]
    (m-1-1) edge node [above] {$y$} (m-1-2)
    (m-1-1) edge node [left]  {$y p_x$} (m-2-1)
    (m-1-2) edge node [right] {$\alpha$} (m-2-2)
    (m-2-1) edge node [above] {$x$} (m-2-2);
\end{tikzpicture}
\end{center}
\end{definition}

\begin{definition} (Послабляючий морфізм). Складається з:
1) функтора природніх моделей $F: C \rightarrow D$,
2) природне перетворення $\phi_{Ty} : F_! Ty_C \rightarrow Ty_D$,
3) природне перетворення $\phi_{Tm} : F_! Tm_C \rightarrow Tm_D$,
такими що наступа діаграма комутує:
\begin{center}
\begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=3em,minimum width=2em]
  {
     F_! Tm(C) & Tm(D) \\
     F_! Ty(C) & Ty(D) \\};
  \path[-stealth]
    (m-1-1) edge node [above] {$\phi_{Tm}$} (m-1-2)
    (m-1-1) edge node [left]  {$F_! p(C)$} (m-2-1)
    (m-1-2) edge node [right] {$p(D)$} (m-2-2)
    (m-2-1) edge node [above] {$\phi_{Ty}$} (m-2-2);
\end{tikzpicture}
\end{center}.

Тут $F_! : \textbf{Set}^{C^{op}} \rightarrow \textbf{Set}^{D^{op}}$ є лівим розширенням Кана.
\end{definition}

\newpage
\subsection{Модельні категорії Квіллена}
Дисертація Деніела Квіллена була присвячена диференціальним рівнянням, але відразу після цього він
перевівся в МІТ і почав працювати в алгебраїчній топології, під впливом Дена Кана.
Через три роки він видає Шпрінгеровскі лекції з математики "Гомотопічна алгебра", яка
назавжди транформувала алегбраїчну топологію від вивчення топологічних просторів з точністю до гомотопий
до загального інструменту, що застосовується в інших областях математики.

Модельні категорії вперше були успішно застосовані Воєводським для доказу
кон'юнктури Мілнора (для 2) і потім мотивной кон'юнктури Блоха-Като (для n).
Для доказу для 2 була побудована зручна стаблільная гомотопічні категорія
узагальнених схем. Інфініті категорії Джояля, досить добре досліджені Лур'є
є прямим узагальненням модельних категорій.

Цікавою властивістю модельних категорій є те, що дуальні до них категорії
перевертають розшарування і корозшарування, таким природнім чином реалізують
дуальність Екмана-Хілтона. Розшарування і корозшарування пов'язані, тому взаємовизначені.
Корозшарування є морфізмами, що мають властивість лівого гомотопічні
підйому по відношенню до ациклічним розшарування і розшарування є морфізмами,
що мають властивість правого гомотопічні підйому по відношенню до ациклічних корозрашувань.

\newpage
\section{Спектральна категорія формальних мов}
Категорії, об'єкти яких є мови програмування, або точніше їх синтаксиси (ініціальні об'єкти), а
морфізми --- транформаціями цих синтаксичних дерев (верифікаторами, компіляторами, екстраторами)
є об'єктом дослідження концептуальної ситсеми мов.

В той час, як категорні моделі теорії типів працюють з контекстуальними категоріями
та двома досніпами $Tm$ та $Ty$ які моделюють типи та терми в категорії множин,
мовні категорії призначені для моделювання різних теорій типів та різних
відповідних досніпів, а також перетворень між ними.

\begin{definition} (Синтаксичне дерево).
Синтаксичне дерево --- це індуктивний тип або дерево Бома,
контруктори якого відповідають одному з 4 типів правил в теорії типів,
як правило використовуються три правила: правило формації, інтро-правила та елімінатор.
\end{definition}

\begin{definition} (Вище синтаксичне дерево).
Синтаксичне дерево в яке додано $\beta$ та $\eta$ правила називається
вищим синтаксичним деревом.
\end{definition}

\begin{definition} (Мова програмування).
Мова програмування або мовна категорія --- це категорія,
об’єкти якої --- це maybe-типи сум синтаксичних дерев мов програмування,
  а морфізми --- це стрілки (які містять правила виводу, типизації, нормалізації, екстакції тощо).
Приклади синтаксичних дерев: $O_\Pi$, $O_\Sigma$, $O_=$.
Приклади мовних категорій: $O_{PTS}$, $O_{MLTT}$, $O_{HTS}$.
\end{definition}

\begin{definition} (Модель).
Модель визначимо як систему формальних мов (об'єкти) разом з їх програмами,
та мовними перетвореннями (звязки) між ними для яких працює правило асоціативності
композиції та правила лівої і правої композиції з одиничними стрілками.
Іншими словами будемо розуміти тут категорну модель.
\end{definition}

\begin{definition} (Послідовність синтаксичних дерев). Кожна послідовність
синтаксичних дерев
\begin{equation}
O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I.
\end{equation}
генерує відповідну послідовність мов програмування
\begin{equation}
\begin{split}
O_{PTS}(O_\Pi) \rightarrow O_{CTX}(O_\Pi,O_\Sigma) \rightarrow O_{EQU}(..,O_\Sigma,O_=) \rightarrow \\
 \quad \rightarrow O_{ITS}(...,O_=,O_W) \rightarrow O_{HTS}(...,O_W,O_I).
\end{split}
\end{equation}
наступним чином. Кожна мова програмування залежить
від синтаксису який її визначає
та всіх попредніх синтаксисів мов програмування з послідовності.
Перша мова програмування містить тільки перший синтаксис.
Розкриті сигнатури мають вигляд:
$O_{PTS}: O_\Pi \rightarrow U$,
$O_{CTX}: O_\Pi \rightarrow O_\Sigma \rightarrow U$,
$O_{EQU}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow U$,
$O_{ITS}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow U$,
$O_{HTS}: O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I \rightarrow U$.
\end{definition}

Таким чином кожна наступна мова програмування містить усі попередні
мови програмування, визначені послідовністю синтаксичних дерев,

\begin{definition} (Створення мовної категорії).
Мови можна додавати, наприклад $O_{HTS} = O_{\Pi\Sigma=WI}$, для побудови якої необхідно
об'єднати у індуктивному типі мови усі індуктивні типи її підмов.
Таким чином функтор діє на декартовому добутку синтаксичних дерев мовних категорій
та має значення в категорій мовних категорій. Приклад найпотужнішої гомотопічної мови:
\begin{equation}
O_{HTS} = O_{\Pi\Sigma=WI} : O_\Pi \rightarrow O_\Sigma \rightarrow O_= \rightarrow O_W \rightarrow O_I \rightarrow U.
\end{equation}
\end{definition}

Кожне синтаксичне дерево, як правило, містить конструктори
та елімінатори певного одного типу. Але починаючи з $O_{ITS}$
складність типів, які додаються до ядра значно зростає.
Таким чином мовні категорії конструються гранулярно з
точністю до включення певного типу в ядро верифікатора.

\begin{definition} (Типи синтаксичних дерев).
У розділі 1 були проаналізовані усі мови програмування та середовища виконання,
а також спеціалізовані мови моделювання. В результаті чого було встановлено
чітки індивідуальні мовні синтаксиси. Кожен синтаксис складається з
множини синтаксичних одиниць цієї мови (конструктори індуктивного типу),
які відповідають правилам теорії типів Мартіна-Льофа (формації, інтро-правило,
елімінатор, $\beta$-, та $\eta$-правила). Якщо додати $\beta$-, та $\eta$-правила
як рівності у визначення синтаксису, то для представлення потрібні вищі індуктивні типи.
Таким чином кожному синтаксичному дереву відповідає певний тип в теорії типів Мартіна-Льофа.
\begin{table}
  \caption{Аналіз формальних суб-мов як примітивів ядра}
 \begin{tabular}{lcc}
    \hline
       \textbf{Мова} & \textbf{Застосування} \\
    \hline
    \rowcolor{LightGray}
       $O_\lambda$                     & Нетипизоване $\lambda$-числення Чорча (інтерпретація) \\
    \rowcolor{LightGray}
       $O_\pi$                         & Числення процесів, CCS, CSP або $\pi$-числення Мілнера\\
    \rowcolor{LightGray}
       $O_\mu$                         & Тензорне числення (векторизація) \\
    \hline
    \rowcolor{LightGray}
       $O_\Pi$                         & Числення конструкцій (функціональна повнота) \\
    \rowcolor{LightGray}
       $O_\Sigma$                      & Числення контекстів (контекстуальна повнота) \\
    \rowcolor{LightGray}
       $O_=$                           & Теорія типів Мартіна-Льофа (логіка) \\
    \rowcolor{LightGray}
       $O_W$                           & Числення (ко-)індуктивних конструкцій (матіндукція) \\
    \rowcolor{LightGray}
       $O_{I}$                         & Гомотопічна система типів (формальна математика) \\
    \rowcolor{LightGray}
       $O_{\triangleright}$            & Кубічна система с обмежувальною рекурсією \\
      \hline
       $O_{/}$                         & Система фактор-типів (Lean) \\
       $O_{H}$                         & Мова з оператором Адамара (квантова фізика)\\
       $O_{\dashv}$                    & Модальна HoTT (фізика)\\
      \hline
  \end{tabular}
  \small Сірим кольором показаний спектр мовних примітивів ядра концептуальної моделі.
\end{table}
\end{definition}

\begin{definition} (Спектральна категорія мов).
Так, виділяється наступна послідовність мов, та функторів між ними,
де кожна мова-кодомен є складнішою та біль потужною за мову-домен.
Система мов є категорією мовних категорій або категорією мов програмування.
\begin{equation}
O_\infty : O_{CPS} \rightarrow O_{PTS} \rightarrow O_{MLTT} \rightarrow O_{ITS} \rightarrow O_{HTS} \rightarrow ...
\end{equation}
\end{definition}

\begin{definition} (Коконтекстуальна категорія мов).
Якщо не виділяти певну послідовність мовного ускладнення та розглядати
усі суми усієї певної множини мовних синтаксисів, то ми отриміємо коконтекстуальну категорію,
де об'єкти --- це усі можливі мовні категорії побудовані за допомогою усіх перестановок суми мовних синтаксисів,
а морфізми це функтори перетворення однієї мовної категорії в іншу мовну категорію.
Приклади: $O_{I*} \rightarrow O_{\Pi=}$, $O_\Pi \rightarrow O_{\Pi\Sigma}$,
$O_\Pi \rightarrow O_{\Pi\Sigma}$, $O_{\Pi*} \rightarrow O_\Pi$.
\end{definition}

\section{Структурне представлення моделі}
Виходячи з визначення моделі, вони можуть мати різний
набір об'єктів в системі мов програмування.
Покажемо приклади ексземплярів які можно породити в рамках цієї моделі.

\newpage
\subsection{Мінімальна система}
Приклад мінімальної системи, яка містить лише одну мову для доведення теорем
та одну мову для виконання програм.
\begin{equation}
PTS_{CPS} = 
\begin{cases}
Ob: \{ O_{CPS}, O_{PTS} \} \\
Hom: \{ 1,2: \mathbb{1} \rightarrow O_{PTS}, 3: O_{PTS} \rightarrow O_{CPS} \}
\end{cases}
\end{equation}
\begin{center}
\begin{figure}[ht]
  \centerline{\includegraphics[scale=0.6]{minimal.eps}}
  \caption{Мінімальна система з чистої мови та інтерпретатора}
\end{figure}
\end{center}
Стрілки 1 та 2 визначають
модель та базову бібліотеку, а стрілка 3 означає екстракт
доведення (якщо таке є) в інтерпретатор. Можна використати графічну
мову мереж Петрі для зображення екземпляра моделі системи мов.

\newpage
\subsection{Максимальна система}
Інший приклад системи --- це максимальна система, яка містить усі формальні
мови програмування та формальне середовище виконання (порядок синтаксичних дерев
як параметрів при конструюванні мовної категорії може змінюватися, тут
генеалогія HTS не ведеться від MLTT, яке є розгалуженням).
\begin{equation}
Total = 
\begin{cases}
Ob: \{ O_{CPS}, O_{PTS}, O_{MLTT}, O_{ITS}, O_{HTS} \} \\
Hom: \begin{cases}
1,2: \mathbb{1} \rightarrow O_{HTS}, 3: O_{MLTT} \rightarrow O_{ITS} \\
4: O_{HTS} \rightarrow O_{ITS}, 5: O_{ITS} \rightarrow O_{PTS}, 6: O_{PTS} \rightarrow O_{CPS}
\end{cases}
\end{cases}
\end{equation}
За допомогою мереж Петрі це можна відобразити наступним чином:
\begin{center}
\begin{figure}[ht]
  \centerline{\includegraphics[scale=0.6]{higher.eps}}
  \caption{Кубічна та чиста системи типів та середовище виконання}
\end{figure}
\end{center}


\newpage
\subsection{Категорія середовища виконання CPS}
\begin{definition} (Категорія середовища виконнання $O_{CPS}$).
$$
O_{CPS} =
\begin{cases}
Ob: \{\ maybe\ CPS\ \} \\
Hom: \{\ eval: Ob \rightarrow Ob\ \}
\end{cases}
$$
\end{definition}

Синтаксис середовища виконання може містити наступні синтаксиси:
$O_\lambda$, $O_\pi$, $O_\mu$.

\begin{definition} (Синтаксис мовної категорії $O_{CPS}$).
\begin{lstlisting}
data CPS = lambda (_: church CPS)
         | process (_: milner CPS)
         | tensor (_: futhark CPS)
\end{lstlisting}
\end{definition}

Формальне середовище виконання складається з інтерпретатора
(нетитизованого $\lambda$-числення) та числення акторів (процесів, черг, таймерів).
Інтерпретатор та операційна система включені в систему доведення теорем
для уніфікації всіх сигнатур системи та формалізації самого інтерпретатора
як системи виконання. Слід зазначити, що не
завжди є змога зробити екстракт в $O_{CPS}$, тому об'єкти мовних
категорій є $maybe$-типами.
$$
O_{CPS}: O_\lambda \rightarrow O_\pi \rightarrow O_\mu \rightarrow U
$$
Далі буде йтися тільки про формальні інтерпретатори,
так як вони є найбільш компакними формами мов для
верифікації (в порівнянні з моделями System F).
Таким чином будемо розглядати формальне середовище виконання, як
сукупність інтерпретатора та операційної системи.


\begin{definition} (Синтаксичне дерево $O_\lambda$). Інтерпретатор визначається
своїм трьома конструкторами: номер змінної (індекс де Брейна),
лямбда функція та її апплікація:
\begin{lstlisting}
data church = var (x: nat)
            | lam (l: nat) (d: cps)
            | app (f a: cps)
\end{lstlisting}
Мовою інтерпретаторів є нетипизоване лямбда числення, однак в залежності
від складності інтерпретатора це дерево може виглядати по-різному.
\end{definition}

В цьому розділі ми побудуємо надшвидку імплементацію інтерпретатора,
яка цілком, разом зі своїми програмами, розміщується в кеш-памяті
першого рівня процесору, та здатна до AVX векторизацій засобами мови Rust.
Як промислова опція, підтримується також екстракт
в байт-код інтерпретатора BEAM віртуальної машини Erlang.

\begin{definition} (Синтаксичне дерево $O_\pi$).
Правило формації, конструктора та елімінатора визначається синтаксичним деревом $O_*$:
\begin{lstlisting}
data milner (lang: U)
   = process (protocol: lang)
   | spawn (cursors: lang) (core: nat) (program: lang)
   | snd (cursor: lang) (data: lang)
   | rcv (cursor: lang)
   | pub (size: nat)
   | sub (cursor: lang)
\end{lstlisting}
\end{definition}

\begin{definition} (Синтаксичне дерево $O_\mu$).
\begin{lstlisting}
data futhark (lang: U)
   = iota (cursor: lang)
   | map (cursor: lang)
   | fold (size: nat)
   | scan (cursor: lang)
   | for (cursor: lang)
   | while (cursor: lang)
   | concat (cursor: lang)
   | zip (cursor: lang)
   | transpose (cursor: lang)
\end{lstlisting}
\end{definition}

\newpage
\section{Вищі формальні мови програмування}
Тут йдеться про мови програмування придатні для доведення теорем,
та їх таксономію від найелементарніших (чистої системи з одним типом $\Pi$) до
найпотужніших гомотопічних систем. Одна така гомотопічна система є кінцевим завданням
цього розділу --- побудова моделі гомотопічного верифікатора.
В процесі його побудови в цьому розділі ми розглянемо під
мікроскопом складові частини його нижчих мовних рівнів.

Застосуємо категорну семантику для мов програмування і будемо розглядати
мови програмування як моноїдальні мовні категорі, об'єкти яких є просторами
усіх програм цих мов програмування, а морфізми --- правила верифікації та компіляції цих мов.
Морфізми між мовними категоріями в категорї мов програмування --- це
функтори підвищення та пониження складності мови, подібно до того як діють
морфізми в контекстуальних категоріях. Морфізм деконструює або конструює за
допомогою Either-типу або $\Sigma$-типу індуктивний тип мови програмування.

Мови розкладаються у спектральну (індексовану натуральними числами $N \rightarrow U$)
послідовність мов, кожен елемент якої є мовою програмування,
яка не містить синтаксичне дерево вищої мови програмування.

\newpage
\subsection{Чиста система типів PTS}
Чиста ситема або числення конструкцій або система з одим типом або
система з однією аксіомою, продовжує традиції елементарних пруверів
в стилі першого AUTOMATH та сучасних Henk, Morte, Cedile, Om.

\begin{definition} (Мовна категорія чистої мови $O_{PTS}$).
\begin{equation}
O_{PTS} =
\begin{cases}
Ob: \{\ X: maybe\ PTS, target: maybe\ CPS \ \} \\
Hom: \begin{cases}
type,norm: X \rightarrow X, extract: X \rightarrow target \\
certify: X \rightarrow target = type \circ norm \circ extract
\end{cases}
\end{cases}
\end{equation}
\end{definition}

\begin{definition} (Синтаксис мовної категорії $O_{PTS}$).
Чиста мова $O_{PTS}$ містить лише синтаксис одного типу, $\Pi$-типу.
Така теорія називається теорією з одним типом, або з однією аксіомою.
\begin{lstlisting}
data PTS = ppure (_: pts PTS)
\end{lstlisting}
\end{definition}

Вона описана в літературі як Calculus of Construction (Кокан),
Pure Type System (Стемп, Фу).

\begin{definition} (Синтаксичне дерево $O_\Pi$).
\begin{lstlisting}[mathescape=true]
data pts (lang: U)
   = star (n: nat)
   | var (x: name) (l: nat)
   | pi (x: name) (l: nat) (f: lang)
   | lambda  (x: name) (l: nat) (f: lang)
   | app (f a: lang)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Теорія типів Мартіна-Льофа MLTT$}
Мова теорії типів є сучасною основою всіх пруверів з залежними типами,
такими, наприклад, як NuPRL та Agda. Багато так званих $\Pi\Sigma$ пруверів
імплементують $MLTT$ серед таких як:
$\Pi\Sigma$\footnote{\url{https://github.com/zlizta/pisigma-0-2-2}},
$\Pi\forall$\footnote{\url{https://github.com/sweirich/pi-forall}}.

\begin{definition} (Мовна категорія $O_{MLTT}$).
\begin{equation}
O_{MLTT} =
\begin{cases}
Ob: \{\ maybe\ MLTT\ \} \\
Hom: \begin{cases}
type,norm: Ob \rightarrow Ob \\
certify: Ob \rightarrow Ob = type \circ norm
\end{cases}
\end{cases}
\end{equation}
\end{definition}

\begin{definition} (Синтаксис мовної категорії $O_{MLTT}$).
Мова $O_{MLTT}$ включає в себе синтаксиси трьох типів
теорії Мартіна-Льофа: $O_\Pi$, $O_\Sigma$, $O_=$.
\begin{lstlisting}
data MLTT = mpure (_: pts MLTT)
          | msigma (_: exists MLTT)
          | mid (_: identity MLTT)
\end{lstlisting}
\end{definition}

\begin{definition} (Синтаксичне дерево $O_\Sigma$).
Також можна до чистої системи додати $\Sigma$-тип,
піднявши типову систему до мови $O_{MLTT-72}$ або $O_{\Pi\Sigma}$ :
\begin{lstlisting}[mathescape=true]
data exists (lang: U)
   = sigma (n: name) (a b: lang)
   | pair (a b: lang)
   | fst (p: lang)
   | snd (p: lang)
\end{lstlisting}
\end{definition}

\begin{definition} (Синтаксичне дерево $O_=$).
Додавши тип рівності можно підняти систему ще на одну сходинку,
до $O_{MLTT-84}$ або $O_{\Pi\Sigma=}$:
\begin{lstlisting}[mathescape=true]
data identity (lang: U)
   = id (t a b: lang)
   | id_intro (a b: lang)
   | id_elim (a b c d e: lang)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Система індуктивних типів ITS}

\begin{definition} (Мовна категорія $O_{ITS}$).
\begin{equation}
O_{ITS} =
\begin{cases}
Ob: \{\ X: maybe\ ITS, target: maybe\ CPS\ \} \\
Hom: \begin{cases}
type,norm,induction: X \rightarrow X, extract: X \rightarrow target \\
certify : X \rightarrow target \\
cerfity = type \circ norm \circ induction \circ extract \\
\end{cases}
\end{cases}
\end{equation}
\end{definition}

Мова індуктивних типів дозволяє безпосередньо кодувати індуктивні типи,
не використовуючи схеми кодування Бома, містить усі попередні мовні синтаксиси:
$O_=$, $O_\Sigma$, $O_\Pi$.

\begin{definition} (Синтаксичне дерево мовної категорії $O_{ITS}$).
\begin{lstlisting}
data ITS = ipure (_: pts ITS)
         | isigma (_: exists ITS)
         | iid (_: identity ITS)
         | iITS (_: ind ITS)
\end{lstlisting}
\end{definition}

Мова містить наступні допоміжні визначення: i) телескопу,
який містить послідовність елементів мови; ii) розгалуження,
як конструкцій case оператора; iii) імен конструкторів індуктивного типу.

\begin{lstlisting}
data tele   (A: U) = emp | tel (n: name) (b: A) (t: tele A)
data branch (A: U) =        br (n: name) (args: list name) (term: A)
data label  (A: U) =       lab (n: name) (t: tele A)
                         | com (n: name) (t: tele A) (dim: list name)
                               (s: list  (prod (prod name bool) A))
\end{lstlisting}

\begin{definition} (Синтаксичне дерево $O_*$).
Правило формації, конструктора та елімінатора визначається синтаксичним деревом $O_*$:
\begin{lstlisting}
data ind (lang: U)
   = datum  (n: name) (t: tele lang) (labels:   list (label lang))
   | case   (n: name) (t: lang)      (branches: list (branch lang))
   | ctor   (n: name)                (args:     list lang)
\end{lstlisting}
\end{definition}

\newpage
\subsection{Гомотопічна система типів HTS}

\begin{definition} (Мовна категорія $O_{HTS}$).
$$
O_{HTS} =
\begin{cases}
Ob: \{\ maybe\ HTS\ \} \\
Hom: \begin{cases}
type,norm: Ob \rightarrow Ob \\
certify: Ob \rightarrow Ob = type \circ norm \\
\end{cases}
\end{cases}
$$
\end{definition}

\begin{definition} (Синтаксис мовної категорії $O_{HTS}$).
Синтаксис гомотопічної мовної категорії містить усі
попередні мовні синтаксиси: $O_I$, $O_W$, $O_=$, $O_\Sigma$, $O_\Pi$:
\begin{lstlisting}
data HTS = hpure (_: pts HTS)
         | hsigma (_: exists HTS)
         | hid (_: identity HTS)
         | hind (_: ind HTS)
         | homotopy (_: hts HTS)
\end{lstlisting}
\end{definition}

Гомотопічна типа наслідує $O_{ITS}$ але модифіковану з
Path-типом в індуктивних визначеннях, структурою композиції,
анонсує Path-тип (формація, конструктор, та елімінатор)
як лямбда функцію на відрізку, а також склейку типів у всесвіті
та склейку змінних з відповідними елімінаторами.

\begin{definition} (Синтаксичне дерево $O_I$).
\begin{lstlisting}
data hts (lang: U)
   = pre (n: nat)
   | path (A x y: lang)
   | plam (name: name) (a: lang)
   | papp (f a: lang)
   | I
   | 0
   | 1
   | \\/ (a b: lang)
   | /\\ (a b: lang)
   | neg (e: lang)
   | comp (a b: lang)
   | fill (a b c: lang)
   | glue (a b c: lang)
   | glue-1 (a b: lang)
   | unglue-1 (a b: lang)
\end{lstlisting}
\end{definition}

Таким чином,
$O_{HTS}$ містить два Id-типа, один унаслідований від $O_=$,
а інший який міститься в синтаксичному дереві $O_I$.

\newpage
\section{Висновки}
